# Проект: Сравнение спайковых и традиционных нейронных сетей на MNIST

Этот проект содержит несколько реализаций нейронных сетей для классификации изображений из датасета MNIST (рукописные цифры). Включает спайковые нейронные сети (SNN) с использованием модели Ижикевича и библиотек Brian2 и CuPy, а также "честную" CNN на TensorFlow для сравнения. Каждый файл представляет собой отдельный эксперимент с детальной аналитикой производительности, энергопотребления и вычислительных затрат.

## Общие требования

### Аппаратное обеспечение
- **GPU**: NVIDIA RTX 4060 Ti (или другой GPU с поддержкой CUDA).
- **Операционная система**: Windows, Linux или macOS (Windows используется в примерах).
- **Оперативная память**: Минимум 16 ГБ.
- **Диск**: Минимум 10 ГБ свободного места для установки зависимостей и хранения логов.

### Программное обеспечение
- **Python**: Версия 3.8–3.10 (рекомендуется 3.9 для совместимости).
- **CUDA Toolkit**: Версия, совместимая с вашим GPU (например, CUDA 11.8 для RTX 4060 Ti).
- **cuDNN**: Для работы TensorFlow и CuPy с GPU (например, cuDNN 8.6 для CUDA 11.8).
- **pip**: Для установки зависимостей.

### Установка общих зависимостей
1. Установите Python 3.9 (или другую совместимую версию):
   - Windows: Скачайте установщик с [официального сайта Python](https://www.python.org/downloads/) и установите, добавив Python в PATH.
   - Linux: `sudo apt update && sudo apt install python3.9 python3-pip`.
   - macOS: `brew install python@3.9`.

2. Установите CUDA Toolkit и cuDNN:
   - Скачайте CUDA Toolkit с [сайта NVIDIA](https://developer.nvidia.com/cuda-downloads) (например, 11.8).
   - Скачайте cuDNN с [сайта NVIDIA](https://developer.nvidia.com/cudnn) (требуется регистрация), распакуйте и скопируйте файлы в папку CUDA (например, `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8` на Windows).
   - Добавьте CUDA в PATH:
     - Windows: Добавьте `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8\bin` в переменную окружения PATH.
     - Linux/macOS: `export PATH=/usr/local/cuda-11.8/bin:$PATH`.

3. Создайте виртуальное окружение:
   ```bash
   python3 -m venv venv
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate     # Windows
   ```

4. Установите зависимости из `requirements.txt`:
   ```bash
   pip install -r requirements.txt
   ```
   Содержимое `requirements.txt`:
   ```
   brian2
   numpy
   sklearn
   cupy
   tqdm
   matplotlib
   tensorflow
   ```
   **Примечание**: Если возникают проблемы с `cupy`, установите версию, совместимую с вашей CUDA (например, `pip install cupy-cuda118` для CUDA 11.8). Для TensorFlow может потребоваться `tensorflow-gpu` (устанавливается автоматически, если CUDA настроен).

---

## Файл 1: `brian2_snn.py` — SNN с использованием Brian2

### Описание
Этот скрипт реализует спайковую нейронную сеть (SNN) для классификации MNIST, используя библиотеку Brian2. Сеть включает входной слой (784 нейрона), возбудительный слой (1600 нейронов) и тормозной слой (1600 нейронов). Обучение основано на STDP (Spike-Timing-Dependent Plasticity) с использованием LIF либо `PoissonGroup`, либо `SpikeGeneratorGroup` для генерации входных спайков. Код включает этапы обучения, присвоения меток нейронам и тестирования.

### Зависимости
- `brian2`: Для моделирования SNN.
- `numpy`: Для числовых вычислений.
- `sklearn`: Для загрузки и предобработки данных MNIST.
- `time`: Стандартная библиотека Python.
- `os`: Стандартная библиотека Python.

### Установка
1. Убедитесь, что общие зависимости установлены (см. выше).
2. Если вы ещё не активировали виртуальное окружение:
   ```bash
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate     # Windows
   ```

### Запуск
1. Сохраните код в файл `brian2_snn.py`.
2. Настройте локаль для корректного вывода UTF-8 (особенно важно для Windows):
   ```bash
   chcp 65001           # Windows: Переключение на UTF-8
   set PYTHONUTF8=1     # Windows: Включение UTF-8 в Python
   ```
3. Запустите скрипт с перенаправлением вывода в файл (для удобства):
   ```bash
   python -X utf8 brian2_snn.py > brian2_output.txt 2>&1
   ```
   - `-X utf8`: Указывает Python использовать UTF-8 для корректного вывода.
   - `> brian2_output.txt 2>&1`: Сохраняет весь вывод (включая ошибки) в файл `brian2_output.txt`.

### Ожидаемые результаты
- **Вывод в консоль/файл**:
  - Загрузка данных MNIST: ~3–5 секунд.
  - Количество подключённых синапсов: 1,254,400.
  - Начальные веса: Средний вес ~0.2501, максимальный вес ~0.5000.
  - Обучение на 60,000 примерах (30 эпох).
  - После каждой эпохи: Логирование метрик (спайки, веса, потенциалы, `theta`) в файл `training_log.txt`.
  - Присвоение меток: Распределение нейронов по классам (0–9).
  - Точность на тесте: Ожидается ~76% (на основе предыдущих экспериментов).
- **Файлы**:
  - `training_log.txt`: Метрики после каждой эпохи (спайки, веса, потенциалы, `theta`).

### Возможные проблемы
- **Ошибка с `SpikeGeneratorGroup`**: Если возникает ошибка о множественных спайках в одном временном шаге, переключитесь на `PoissonGroup` (версия кода с `PoissonGroup` уже предоставлена).
- **Кодировка**: Если вывод в консоли некорректен, проверьте настройки локали (`chcp 65001` и `set PYTHONUTF8=1`).

---

## Файл 2: `izhikevich_stdp.py` — SNN с Ижикевичем (STDP/Hebbian)

### Описание
Этот скрипт реализует SNN с моделью нейронов Ижикевича, оптимизированную для работы на GPU с помощью CuPy. Сеть состоит из входного слоя (784 нейрона), скрытого слоя (2048 нейронов) и выходного слоя (10 нейронов). Обучение использует STDP для входного слоя и геббовское обучение с учителем для выходного слоя. Включает аналитику энергопотребления, FLOPs и памяти.

### Зависимости
- `cupy`: Для вычислений на GPU.
- `sklearn`: Для загрузки MNIST, предобработки и разделения данных.
- `tqdm`: Для прогресс-бара.
- `matplotlib`: Для визуализации.
- `csv`: Стандартная библиотека Python.
- `datetime`: Стандартная библиотека Python.

### Установка
1. Убедитесь, что общие зависимости установлены (см. выше).
2. Убедитесь, что CUDA Toolkit и cuDNN настроены (см. выше).
3. Если вы ещё не активировали виртуальное окружение:
   ```bash
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate     # Windows
   ```

### Запуск
1. Сохраните код в файл `izhikevich_stdp.py`.
2. Запустите скрипт:
   ```bash
   python izhikevich_stdp.py > izhikevich_stdp_output.txt 2>&1
   ```
   - `> izhikevich_stdp_output.txt 2>&1`: Сохраняет вывод в файл.

### Ожидаемые результаты
- **Вывод в консоль/файл**:
  - Инициализация GPU: Укажет вашу GPU (например, "NVIDIA GeForce RTX 4060 Ti").
  - Загрузка MNIST: ~3–5 секунд.
  - Обучение на 50,400 примерах (30 эпох).
  - После каждой эпохи: Точность на тренировочной и валидационной выборках, частота спайков, время, энергопотребление.
  - Финальная точность на тесте: Ожидается 40-50%.
  - Пост-тренировочная аналитика: Общее время, энергия, FLOPs, память.
- **Файлы**:
  - `training_metrics_YYYYMMDD_HHMMSS.csv`: Метрики по эпохам (точность, спайки, время, энергия).
  - `training_analysis.png`: Графики (точность, спайки, время, энергия).

### Возможные проблемы
- **Ошибка CUDA**: Если CuPy не находит CUDA, проверьте установку CUDA Toolkit и драйверов NVIDIA.
- **Переполнение памяти GPU**: Если RTX 4060 Ti (8 ГБ) переполняется, уменьшите `BATCH_SIZE` (например, до 64).

---

## Файл 3: `izhikevich_gradient.py` — SNN с Ижикевичем (суррогатный градиент)

### Описание
Этот скрипт реализует SNN с моделью Ижикевича, используя суррогатный градиент для обучения с помощью метода обратного распространения ошибки. Сеть имеет входной слой (784 нейрона), скрытый слой (512 нейронов) и выходной слой (10 нейронов). Оптимизация выполняется с помощью Adam. Код включает детальную аналитику: точность, спайки, энергопотребление, FLOPs, память.

### Зависимости
- `cupy`: Для вычислений на GPU.
- `sklearn`: Для загрузки MNIST, предобработки и разделения данных.
- `tqdm`: Для прогресс-бара.
- `matplotlib`: Для визуализации.
- `csv`: Стандартная библиотека Python.

### Установка
1. Убедитесь, что общие зависимости установлены (см. выше).
2. Убедитесь, что CUDA Toolkit и cuDNN настроены (см. выше).
3. Если вы ещё не активировали виртуальное окружение:
   ```bash
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate     # Windows
   ```

### Запуск
1. Сохраните код в файл `izhikevich_gradient.py`.
2. Запустите скрипт:
   ```bash
   python izhikevich_surrogate.py > izhikevich_surrogate_output.txt 2>&1
   ```
   - `> izhikevich_surrogate_output.txt 2>&1`: Сохраняет вывод в файл.

### Ожидаемые результаты
- **Вывод в консоль/файл**:
  - Инициализация GPU: Укажет вашу GPU.
  - Загрузка MNIST: ~3–5 секунд.
  - Обучение на 50,400 примерах (30 эпох).
  - После каждой эпохи: Точность, потеря, спайки, время, энергопотребление.
  - Финальная точность на тесте: Ожидается ~70–75%.
  - Пост-тренировочная аналитика: Общее время, энергия, FLOPs, память, графики.
- **Файлы**:
  - `training_metrics.csv`: Метрики по эпохам.
  - Графики: 9 графиков (точность, потеря, спайки, время, энергия и др.) отображаются в окне.

### Возможные проблемы
- **Ошибка CUDA**: Аналогично предыдущему файлу.
- **Графики не отображаются**: Если вы работаете в неинтерактивной среде (например, WSL), добавьте `plt.savefig('training_analysis.png')` вместо `plt.show()`.

---

## Файл 4: `honest_cnn.py` — "Честная" CNN на TensorFlow

### Описание
Этот скрипт реализует "честную" CNN для сравнения с SNN. Свёрточные слои удалены, чтобы архитектура соответствовала SNN (784 → 512 → 10). Обучение выполняется с помощью Adam, с той же структурой данных (50,400 тренировочных, 5,600 валидационных, 14,000 тестовых примеров). Включает аналитику: точность, энергопотребление, FLOPs, память, эквивалент спайков.

### Зависимости
- `tensorflow`: Для построения и обучения CNN (с поддержкой GPU).
- `sklearn`: Для загрузки MNIST и разделения данных.
- `matplotlib`: Для визуализации.
- `logging`: Стандартная библиотека Python.
- `csv`: Стандартная библиотека Python.
- `time`: Стандартная библиотека Python.

### Установка
1. Убедитесь, что общие зависимости установлены (см. выше).
2. Убедитесь, что CUDA Toolkit и cuDNN настроены (см. выше).
3. Если вы ещё не активировали виртуальное окружение:
   ```bash
   source venv/bin/activate  # Linux/macOS
   venv\Scripts\activate     # Windows
   ```

### Запуск
1. Сохраните код в файл `honest_cnn.py`.
2. Запустите скрипт:
   ```bash
   python honest_cnn.py > honest_cnn_output.txt 2>&1
   ```
   - `> honest_cnn_output.txt 2>&1`: Сохраняет вывод в файл.

### Ожидаемые результаты
- **Вывод в консоль/файл**:
  - Загрузка MNIST: ~3–5 секунд.
  - Обучение на 50,400 примерах (30 эпох).
  - После каждой эпохи: Точность, потеря, время, энергопотребление.
  - Финальная точность на тесте: Ожидается ~90–95% (выше, чем у SNN, из-за непрерывных активаций).
  - Пост-тренировочная аналитика: Общее время, энергия, FLOPs, память, эквивалент спайков.
- **Файлы**:
  - `honest_cnn_log.log`: Логи обучения.
  - `honest_cnn_metrics.csv`: Метрики по эпохам.
  - Графики: 9 графиков (точность, потеря, спайки, время, энергия и др.).

### Возможные проблемы
- **Ошибка TensorFlow GPU**: Если TensorFlow не видит GPU, проверьте установку CUDA и cuDNN. Возможно, нужно установить `tensorflow-gpu` явно.
- **Переполнение памяти**: Если RTX 4060 Ti переполняется, уменьшите `BATCH_SIZE`.

---

## Общее сравнение

### Производительность
- **Brian2 SNN**: ~76% точности, высокая биоправдоподобность, медленное обучение (~10–20 минут на 30 эпох).
- **Ижикевич (STDP/Hebbian)**: ~70–75% точности, быстрее благодаря GPU (~5–10 минут).
- **Ижикевич (суррогатный градиент)**: ~70–75% точности, ещё быстрее (~3–5 минут).
- **CNN**: ~90–95% точности, самое быстрое обучение (~1–2 минуты).

### Энергопотребление
- Рассчитывается на основе TDP (160 Вт) и времени обучения. CNN потребляет меньше энергии из-за меньшего времени, несмотря на отсутствие спайковой экономии.

### Вычислительная сложность
- SNN: Высокая сложность из-за временных шагов (например, 50 шагов в `izhikevich_surrogate.py`).
- CNN: Меньше FLOPs благодаря отсутствию временной динамики.

---

## Дополнительные рекомендации

- **Оптимизация производительности**: Если обучение SNN слишком медленное, попробуйте уменьшить `HIDDEN_SIZE` или использовать меньшее количество временных шагов.
- **Логирование**: Для долгосрочных экспериментов настройте ротацию логов, чтобы избежать переполнения диска.
- **Визуализация**: Если графики не отображаются, замените `plt.show()` на `plt.savefig()` с указанием имени файла.

